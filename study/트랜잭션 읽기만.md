# 📌 Transaction read only
스프링 어노테이션 `@Transactional` 을 사용하여 얻을 수 있는 이점
- AOP 를 통해 어노테이션만으로 서비스 레이어에서 트랜잭션을 적용할 수 있다.
- 조회 메서드에서 속성으로 `readOnly = true`를 설정하여 성능상 이점을 얻을 수 있다.
- 프록시를 생성하거나 클래스 바이트 코드를 조작하여 트랜잭션의 생성, 커밋, 롤백을 관리해준다.

## ✅ Transaction ?
🔹 정의
> 데이터베이스 관리 시스템 또는 유사한 시스템에서 상호작용의 단위이다.   
> 트랜잭션이 **성공과 실패가 분명하고 상호 독립적**이며, 일관되고 믿을 수 있는 시스템을 말한다.  

🔹 목적
- 오류로부터 복구를 허용하고 데이터베이스를 일관성 있게 유지하는 안정적인 **작업 단위**를 제공한다.
- 동시 접근하는 여러 프로그램 간 격리를 제공한다.

### ACID 
- 원자성 Atomicity : 성공하거나 실패하는 단일 단위로 처리한다.
- 일관성 Consistency : 트랜잭션이 성공하면 언제나 동일한 상태 유지한다.
- 독립성 Isolation : 트랜잭션 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장한다.
- 지속성 Durability : 성공된 트랜잭션은 변경되지 않아야함.

## ✅ readOnly = true
### JPA Persistence Context (영속성 컨텍스트)
JPA의 영속성 컨텍스트가 수행하는 변경감지 기능과 연관 있다. 영속성 컨텍스트는 Entity 조회 시 
초기 상태에 대한 SNAPSHOT을 저장한다. 트랜잭션이 COMMIT 될 때, 초기 상태의 정보를 가지는 SNAPSHOT
과 ENTITY 상태를 비교하여 변경된 내용에 대해 update query를 생성해 쓰기 지연 저장소에 저장한다.

`readOnly = true`를 설정하게 되면 스프링 프레임워크는 JPA의 세션 플러시 모드를 MANUAL로 설정한다. 
> MANUAL 모드는 트랜잭션 내에서 사용자가 수동으로 flush를 호출하지 않으면 자동으로 수행되지 않는 모드이다.

트랜잭션 내에서 강제로 `flush()`를 호출하지 않는 한, **수정 내역에 대해 DB에 적용되지 않는다.** 
이는 조회용으로 가져온 ENTITY 수정을 방지할 수 있고, 트랜잭션 내에서 조회하는 ENTITY는 조회용임을
인식하고 변경 감지를 위한 SNAPSHOT을 따로 보관하지 않으므로 메모리가 절약되는 이점이 존재한다.

### REPLICATION 부하 분산
실제 운영되는 서비스에서는 데이터베이스의 장애를 빠르게 복구하고, 트래픽을 분산하기 위한 실시간
복제 데이터베이스를 운영하는 레플리케이션 방식을 사용할 수 있다.

이러한 데이터베이스 구조를 가져갈 때, `readOnly = ture`가 설정되어 있는 메서드의 경우 Slave DB에서
데이터를 가져오도록 동작한다. 이를 통해 레플리케이션의 목적에 맞게 트래픽 분산을 온전하게 적용할 수 있는 이점이
존재한다.